class Solution:
    def countBits(self, n: int) -> List[int]:
        res = [0]*(n+1)
        for i in range(1,n+1):
            res[i]=res[i>>1]+(i&1)
        return res

# 核心思想：
# 利用动态规划，不重复计算。一个数 i 的二进制‘1’的个数，可以由一个更小的、已算出结果的数推导出来。

# 状态转移方程（核心公式）：
# ans[i] = ans[i >> 1] + (i & 1)

# 公式解读：
# ans[i]: 当前数字 i 的解。
# ans[i >> 1]: i 右移一位后（即 i // 2）的解，这是一个已知的子问题。
# (i & 1): 判断 i 的奇偶性。如果 i 是奇数，结果是1；偶数则为0。
# 一句话总结：
# 当前数的‘1’的个数 = (它除以2的那个数)的‘1’的个数 + (它自己的奇偶性)。
