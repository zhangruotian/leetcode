class Solution:
    def maxCoins(self, nums: List[int]) -> int:
        nums = [1]+nums+[1]
        # 1,3,1,5,8,1
        n = len(nums)
        dp = [[0]*n for _ in range(n)]
        for length in range(2,n):
            for i in range(n-length):
                j = i+length
                for k in range(i+1,j):
                    dp[i][j] = max(dp[i][j],dp[i][k]+dp[k][j]+nums[k]*nums[i]*nums[j])
        return dp[0][n-1]
      
1. 核心思想：逆向思维 & 区间DP
问题：直接按顺序（“先戳哪个”）思考，会导致后续气球的相邻关系改变，子问题互相耦合，无法DP。
解决方案：逆向思考，定义区间 (i, j) 内最后一个被戳破的气球是 k。
好处：当 k 最后被戳破时，它的左右邻居一定是 i 和 j，因为 (i, k) 和 (k, j) 区间内的气球都已经被戳完了。这样问题就被分解为两个完全独立的子问题：求解 dp[i][k] 和 dp[k][j]。

2. DP 状态定义
dp[i][j]：表示戳破开区间 (i, j) 内所有气球能获得的最大金币数。
注意：是不包含 i 和 j 的。i 和 j 只是作为这个区间的“虚拟”边界。

3. 状态转移方程
为了计算 dp[i][j]，我们遍历所有可能的“最后一个被戳破的气球 k” (i < k < j)。
对于每一个 k，总收益 = （戳破左边区间的收益） + （戳破右边区间的收益） + （最后戳破 k 的收益）。
方程：dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] + nums[i] * nums[k] * nums[j])

4. 代码实现细节
预处理 nums：
nums = [1] + nums + [1]
在原数组两边各加一个 1。这极大地简化了边界处理，使得任何气球的左右邻居总能找到值，无需在代码里写 if/else 判断边界。

遍历顺序（关键！）：
for length in range(2, n)：外层循环控制区间长度。我们必须先计算出所有小长度区间的最优解，才能用来计算大长度区间。这是区间DP的典型特征。
for i in range(n - length)：中层循环枚举区间的起始点 i。
j = i + length：根据起始点和长度，计算出区间的终点 j。
for k in range(i + 1, j)：内层循环遍历 (i, j) 区间内所有可能的分割点 k（即最后一个戳破的气球）。

最终答案：
return dp[0][n-1]

n 是添加了 1 之后新数组的长度。dp[0][n-1] 正好对应我们最初的目标：戳破开区间 (0, n-1) 内的所有气球（也就是所有原始气球）能获得的最大收益。

        j=0  j=1  j=2  j=3  j=4  j=5
    i=0 [ 0,   0,   3,  30, 159, 167 ]
    i=1 [ 0,   0,   0,  15, 135, 159 ]
    i=2 [ 0,   0,   0,   0,  40,  48 ]
    i=3 [ 0,   0,   0,   0,   0,  40 ]
    i=4 [ 0,   0,   0,   0,   0,   0 ]
    i=5 [ 0,   0,   0,   0,   0,   0 ]
