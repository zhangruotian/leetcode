class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        # rest[i] = max(rest[i-1],sold[i-1])
        # hold[i] = max(hold[i-1],rest[i-1]-prices[i])
        # sold[i] = hold[i-1]+price[i]
        rest,hold,sold = 0,-prices[0],float('-inf')
        for i in range(1,len(prices)):
            rest,hold,sold = max(rest,sold),max(hold,rest-prices[i]),hold+prices[i]
        return max(rest,hold,sold)

# https://www.youtube.com/watch?v=oL6mRyTn56M
1. 状态的含义
hold[i]: 表示在第 i 天结束时，你持有股票的情况下，到目前为止所能获得的最大利润。
sold[i]: 表示在第 i 天结束时，你刚刚卖出股票的情况下，到目前为止所能获得的最大利润。
rest[i]: 表示在第 i 天结束时，你不持有股票，并且当天没有卖出股票（即处于休息或冷却状态）的情况下，所能获得的最大利润。

2. 状态转移方程的推导
状态转移方程描述了在第 i 天的每个状态是如何从第 i-1 天的状态演变过来的。我们来一步步推导：

hold[i] = max(hold[i-1], rest[i-1] - prices[i])
要达到第 i 天结束时“持有”股票的状态 (hold[i])，只有两种可能：
1.昨天就持有，今天继续持有：你在第 i-1 天就已经持有了股票（最大利润为 hold[i-1]），第 i 天你选择什么都不做（keep holding）。那么到第 i 天结束，你依然持有股票，利润不变，还是 hold[i-1]。
2.昨天是休息状态，今天买入：你在第 i-1 天是不持有股票的休息状态（最大利润为 rest[i-1]），然后在第 i 天决定买入。买入会花费 prices[i] 的成本，所以你的总利润变成了 rest[i-1] - prices[i]。
为什么是 rest[i-1] 而不是 sold[i-1]？ 因为题目规定，卖出股票后（sold[i-1]），第二天必须冷却，不能立即购买。所以你只能从“休息”状态转为“买入”状态。
hold[i] 需要取这两种可能性中的最大值，因此：
hold[i]=max(hold[i−1],rest[i−1]−prices[i])

sold[i] = hold[i-1] + prices[i]
要达到第 i 天“刚刚卖出”股票的状态 (sold[i])，只有一种可能：
1.昨天必须持有，今天卖出：你必须在第 i-1 天持有股票（最大利润为 hold[i-1]），然后在第 i 天以 prices[i] 的价格将其卖出。卖出后，你的总利润就是在昨天的基础上加上今天的卖出价格。
因此，这个方程没有 max，是唯一路径：
sold[i]=hold[i−1]+prices[i]

rest[i] = max(rest[i-1], sold[i-1])
要达到第 i 天“休息”（不持有且不卖出）的状态 (rest[i])，有两种可能：
1.昨天就是休息状态，今天继续休息：你在第 i-1 天就是休息状态（最大利润为 rest[i-1]），今天你继续什么都不做。利润不变，还是 rest[i-1]。
2.昨天刚刚卖出，今天强制冷却：你在第 i-1 天刚刚卖出了股票（最大利润为 sold[i-1]），那么第 i 天你被强制进入冷却期，只能休息。利润不变，还是 sold[i-1]。
rest[i] 需要取这两种情况的最大值，因此：
rest[i]=max(rest[i−1],sold[i−1])

3. DP 值的初始化
初始化是动态规划的起点，我们需要为第 0 天（i=0）设置合理的初始值。

hold[0]: 在第 0 天，如果要持有股票，只可能是在当天买入。所以利润就是 -prices[0]（花费了 prices[0] 的成本）。
hold[0]=−prices[0]

rest[0]: 在第 0 天，如果处于休息状态，说明我们什么都没做，没有交易，所以利润是 0。
rest[0]=0

sold[0]: 在第 0 天，你不可能处于“刚刚卖出”的状态，因为要卖出，你必须在第 -1 天就持有股票，这不符合逻辑。这是一个不可能发生的状态。在动态规划中，对于不可能的状态，通常将其初始化为一个极小值（比如负无穷大），以确保它在 max 运算中不会被选中。
sold[0]=−∞
一个编程技巧：在某些实现中，sold[0] 也可以被初始化为 0。虽然逻辑上不严谨，但因为 rest[1] = max(rest[0], sold[0]) = max(0, 0) = 0，这个结果依然是正确的（第1天休息的最大利润是0），所以这个初始值不会对后续计算产生错误影响，可以简化代码。

总结
通过以上三个状态和转移方程，我们可以从第 1 天开始，一天天向后计算，直到最后一天。
最终的最大利润是什么呢？在最后一天（n-1）结束时，我们肯定不希望手里还持有股票（因为无法再卖出），所以最终结果应该是在“卖出”状态和“休息”状态中取一个最大值。
最终答案: max(sold[n-1], rest[n-1])
